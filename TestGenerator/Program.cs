using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TestsGeneratorLib;
namespace TestGenerator
{
    class Program
    {
        private static string GetFullNameSpace(SyntaxNode @class)
        {
            string ClssNameSpace = "";

            while (!(@class.Parent is CompilationUnitSyntax))
            {
                if (@class.Parent is ClassDeclarationSyntax)
                {
                    ClssNameSpace = ClssNameSpace.Insert(0, '.' + (@class.Parent as ClassDeclarationSyntax).Identifier.Text);
                }
                if (@class.Parent is NamespaceDeclarationSyntax)
                {
                    ClssNameSpace = ClssNameSpace.Insert(0, '.' + ((@class.Parent as NamespaceDeclarationSyntax).Name as IdentifierNameSyntax).Identifier.Text);
                }
                @class = @class.Parent;
            }
            return ClssNameSpace.Remove(0,1);
        }
        const string textProgram = @"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TestGenerator
{
    namespace Test{
        class test
        {
            public int testProp { get; set; }
            public int testFields;
            public void TestMeth()
            {

            }
            public class shit
            {
                int i;
                public void TestMeth()
                {

                }
            }
        }
    }
    namespace Huo
    {
        class hias
        {
            private void TestMeth()
            {

            }
            public void dasda(){}
public void da12sda(){}
        }
    }
}

";
        private static MethodDeclarationSyntax[] TestMethodsGenerate(IEnumerable<MemberDeclarationSyntax> methods)
        {
            List<MethodDeclarationSyntax> testMethods = new List<MethodDeclarationSyntax>();

            foreach(MemberDeclarationSyntax method in methods)
            {
                var teshMethod = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName("void"), (method as MethodDeclarationSyntax).Identifier.Text+"Test")
                    .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                        .AddAttributeLists(SyntaxFactory.SingletonList<AttributeListSyntax>(
                            SyntaxFactory.AttributeList(
                                SyntaxFactory.SingletonSeparatedList<AttributeSyntax>(
                                    SyntaxFactory.Attribute(
                                        SyntaxFactory.IdentifierName("Test"))))).ToArray()).WithBody(SyntaxFactory.Block());
                teshMethod= teshMethod.AddBodyStatements(SyntaxFactory.ParseStatement("Assert.Fail(\"autogenerated\");"));
                testMethods.Add(teshMethod);
            }
            return testMethods.ToArray();
        }
        static void FindMethod(SyntaxNode namespac, CompilationUnitSyntax root,ref List<string> Tests)
        {
            var classes = namespac.ChildNodes().Where(@class => @class is ClassDeclarationSyntax);
            foreach (ClassDeclarationSyntax @class in classes)
            {
                var members = @class.Members;
                var methods = members.Where(mem => mem is MethodDeclarationSyntax);
                methods = methods.Where(method => method.Modifiers.Where(modifier => modifier.Kind() == SyntaxKind.PublicKeyword).Any());
                if (methods.Count()>0)
                {
                    var usings = root.Usings;
                    var syntaxFactory = SyntaxFactory.CompilationUnit();
                    syntaxFactory = syntaxFactory.AddUsings(usings.ToArray());
                    syntaxFactory = syntaxFactory.AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("NUnit.Framework")));
                    syntaxFactory = syntaxFactory.AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(GetFullNameSpace(@class))));
                    var namespaceName = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(GetFullNameSpace(@class) + ".Tests"));

                    
                    ClassDeclarationSyntax TestClass = SyntaxFactory.ClassDeclaration(@class.Identifier.Text + "Tests")
                    .WithModifiers(
                        SyntaxFactory.TokenList(
                            SyntaxFactory.Token(SyntaxKind.PublicKeyword)));
                    TestClass=TestClass.AddAttributeLists(SyntaxFactory.SingletonList<AttributeListSyntax>(
                            SyntaxFactory.AttributeList(
                                SyntaxFactory.SingletonSeparatedList<AttributeSyntax>(
                                    SyntaxFactory.Attribute(
                                        SyntaxFactory.IdentifierName("TestFixture"))))).ToArray());

                    TestClass=TestClass.AddMembers(TestMethodsGenerate(methods));
                    namespaceName = namespaceName.AddMembers(TestClass);
                    syntaxFactory = syntaxFactory.AddMembers(namespaceName);
                    Tests.Add(syntaxFactory.NormalizeWhitespace().ToFullString());
                }
                foreach (MemberDeclarationSyntax member in members)
                {
                    if (member is ClassDeclarationSyntax)
                    {
                        FindMethod(@class,root,ref Tests);
                    }
                }
            }
            var namespaces = namespac.ChildNodes().Where(@class => @class is NamespaceDeclarationSyntax);
            foreach(NamespaceDeclarationSyntax @namespace in namespaces)
            {
               FindMethod(@namespace,root,ref Tests);
            }
        }
        static void Main(string[] args)
        {
            List<string> inputFiles = new List<string>();
            inputFiles.Add(@"D:\5 сем\СПП\test.cs");
            string outputPath = @"D:\5 сем\СПП\Tests";
            new FileGenerator().Generate(inputFiles, outputPath,2,2,2);
            Console.ReadLine();
        }
    }
}

